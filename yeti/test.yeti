
program test;

af = load may.stream.audiofile;
plot = load may.plot;
cm = load may.matrix.complex;
mat = load may.matrix;
vec = load may.vector;
win = load may.signal.window;
mm = load may.mathmisc;
manipulate = load may.stream.manipulate;
syn = load may.stream.syntheticstream;
test = load may.test;

{ makeKernel } = load cqtkernel;
{ cqt } = load cqt;

// We want to test:
// 
// Kernel design -- check size (number of bins, number of atoms);
// check an example kernel against known data
//
// Time alignment -- feed a dirac train, check that peaks in all bins
// align
//
// Frequency discrimination -- feed a sinusoid, check peaks
//
// Latency compensation -- for dirac at 0, check peak can be found at
// 0 plus the declared latency
//
// Signal-noise ratio
//
// Specimen output for simple test case

// Test with a single windowed sinusoid, repeating at various frequencies

sinTestStream sampleRate duration signalFreq = // duration is in samples
   (sin = syn.sinusoid sampleRate signalFreq;
    chunk = mat.getRow 0 (sin.read duration);
    syn.precalculatedMono sampleRate (win.windowed win.hann chunk));

// We want to make a CQ transform spanning more than one octave, but
// not going all the way to fs/2 so we can test it also with
// frequencies above and below its extents

sampleRate = 100;

// fs/2 = 50 so 10->40 gives us 2 octaves
cqmin = 10;
cqmax = 40;
bpo = 4; // fairly arbitrary

testFreqs = map (* 5) [ 0..10 ];
duration = sampleRate * 2;

streamBuilder = sinTestStream sampleRate duration;

binForFreq f =
    mm.round (bpo * mm.log2 (f / cqmin)) - 1;

for testFreqs do f:
    str = streamBuilder f;
    cq = cqt { maxFreq = cqmax, minFreq = cqmin, binsPerOctave = bpo } str;
    m = mat.concatHorizontal (map cm.magnitudes cq.output);
    println "binFrequencies = \(cq.kernel.binFrequencies)";
    println "binForFreq \(f) = \(binForFreq f)";
    success = all id
       (map do c:
            // passes test if the correct max bin, or the expected max
            // is out of range, or if all bins are below a threshold
            expected = binForFreq f;
            good =
               (expected < 0 or expected >= vec.length c) or
               (vec.max c < 0.001) or
               (vec.maxindex c == binForFreq f);
            if (not good) then
                println " * bad! maxindex \(vec.maxindex c) != expected \(binForFreq f) for freq \(f) in column: \(vec.list c)";
//                println "matrix is:";
//                mat.print m;
            else 
                print "âœ“"; 
            fi;
            good;
            done (mat.asColumns m));
    println " success = \(success) for freq \(f)";
done;



/*
//testStream = manipulate.withDuration 96000 (syn.sinusoid 48000 500);
//testStream = manipulate.withDuration 96000 (syn.pulseTrain 48000 4);
testStream = af.open "sweep-48000.wav";
//testStream = af.open "sweep.wav";

// So the stream is [ 0, 1, 0, -1, 0, 1, 0, -1, ... ] :
//testStream = manipulate.withDuration 64 (syn.sinusoid 8 2);

testStream = manipulate.withDuration 32 (syn.pulseTrain 8 0.001);

eprintln "have test stream";

cq = cqt { maxFreq = testStream.sampleRate/2, minFreq = 50, binsPerOctave = 24 } testStream;

eprintln "bin frequencies: \(cq.kernel.binFrequencies)";

bigM = mat.concatHorizontal (map cm.magnitudes cq.output);

eprintln "overall output size = \(mat.size bigM)";

mat.print bigM;

//\() (plot.plot [Contour bigM]);
\() (plot.plot [Grid bigM]);
*/
()

